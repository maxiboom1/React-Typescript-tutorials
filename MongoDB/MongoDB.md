# ***MongoDB***

MongoDB is a NoSQL database belonging to the NoSQL database family.

Databases are classified into two groups:
1. Relational Databases: A type of database that contains tables and can also include links between tables. SQL language works on such databases. Examples include MySQL, SQL-Server, PostgreSQL, DB2, Access, and more.
2. NoSQL Databases: This is a type of database that holds data in a different way than tables, often using JSON. SQL language does not work on such databases. It is generally much faster than relational databases. Examples include MongoDB, Elasticsearch, Cassandra, and more.

# ***Installation***
The native mongoDB manager software is Compass, and it can be installed as an option in mongoDB installation pack.

## ***Collection***

A collection is a set of objects, similar to a table.

## ***Document***

A document is an individual object that exists within a collection. It is equivalent to a record in a table.

# ***_id***

The uniq object id that generated by the DB automatically and assigned to each item. 
This is an good practice to keep the underline in id name in code models, services an etc...
So, if you use mongodb, just use "_id" instead "id" in your variable naming to avoid problems.

# ***Import/Export***

1. We need to install MongoDB Command Line Database Tools (https://www.mongodb.com/try/download/database-tools).
2. Extract tools in C:\Program Files\MongoDB\Server\6.0\bin
3. Export: Open terminal on C:\Program Files\MongoDB\Server\6.0\bin>mongodump -d YourDataBaseName  dump/YourDataBaseName. This command will create "dump" folder and inside folder with desired database.
4. Import: Open terminal on C:\Program Files\MongoDB\Server\6.0\bin>mongorestore -d YourDataBaseName  pathToDatabase.

- There is attached snapshots in this folder, that describe those operation.

## ***ORM***

ORM stands for Object Relational Mapper. It is a library that allows representing data in a database using objects in memory. Instead of executing queries on the data and sending the query to the database, you can build an object that contains queries and operations on the data.

## ***Mongoose***

Mongoose is an ORM library for MongoDB. It enables working with objects that store data in the database.

Installation: `npm i mongoose`

# ***Dal service***

Example of dal service that connects to MongoDB, using mongoose library:

```
import mongoose from "mongoose";

async function connect(): Promise<void> {
    try {
        const db = await mongoose.connect("mongodb://127.0.0.1:27017/YourDatabaseName");
        console.log(`We're connected to ${db.connections[0].name} on MongoDB`);
    }
    catch(err: any) {
        console.log(err);
    }
}

export default {
    connect
};

```
And start the service on server start (app.ts):

```
server.listen(appConfig.port, async () => {
    await dal.connect();
    console.log("Listening on http://localhost:" + appConfig.port);
});

```
# ***Using mongoose ORM in model***

Building a complex model involves three components:
1. Interface that describes what is in the model.
2. Schema, which is built from the interface and defines additional rules for each attribute.
3. Class that describes the model.

Operation principle:
- If we want to describe the model as a type of variable received by a function, returned from a function, etc., we use the interface.
- If we want to perform an operation with the model, we use the model class.

Example:

```
import mongoose from "mongoose";

// 1. Interface representing our model:
export interface IProductModel extends mongoose.Document {
    // We do not declare the _id
    name: string;
    price: number;
    stock: number;
    categoryId: mongoose.Schema.Types.ObjectId;
}

// 2. Schema built on the interface, containing more things:
export const ProductSchema = new mongoose.Schema<IProductModel>({
    name: {
        type: String,
        trim: true,
        unique: true,
        required: [true, "Missing name."],
        minlength: [2, "Name too short."],
        maxlength: [100, "Name too long."],
    },
    price: {
        type: Number,
        required: [true, "Missing price."],
        min: [0, "Price can't be negative."],
        max: [1000, "Price can't exceed 1000."]
    },
    stock: {
        type: Number,
        required: [true, "Missing stock."],
        min: [0, "Stock can't be negative."],
        max: [1000, "Stock can't exceed 1000."]
    },
    categoryId: mongoose.Schema.Types.ObjectId
}, {
    versionKey: false // Cancel auto created version property
});

// 3. Model - The final class:
export const ProductModel = mongoose.model<IProductModel>("ProductModel", ProductSchema, "products"); // Model name, Schema, collection name

```

# Create queries

Ok, so now we have dal and model with implemented ORM. 

Lets see how to query data.

* Get all data:
```
function getAllProducts(): Promise<IProductModel[]> {
    return ProductModel.find().exec();
}
```
* Get data by id:
```
async function addProduct(product: IProductModel): Promise<IProductModel> {
    return product.save();
}
```
* Update data by id (use 'returnOriginal:false' to get updated object):
```
async function updateProduct(product: IProductModel): Promise<IProductModel> {
    return await ProductModel.findByIdAndUpdate(product._id, product, { returnOriginal: false }).exec();
}
```
* Delete by id:
```
async function deleteProduct(_id: string): Promise<void> {
    await ProductModel.findByIdAndDelete(_id).exec();
}
```


